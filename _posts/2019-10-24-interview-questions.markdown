---
layout: post
title: Interview Questions
categories: [development]
tags: [question]
---

<br>面试逻辑题： 个人作为面试官的样题，主要针对社招/校招，附上参考答案。

<br>

<h3>A . 抛硬币</h3>
> 设有一个正反两面的硬币，A 和 B 两人轮流抛硬币，当硬币序列出现特定状况时游戏结束，否则无限进行下去，直到满足规则结束

<br>

##### (1)  若硬币抛出“正面”时游戏结束，抛出"正面"的人获胜，

#####        则先手获胜的概率是多少

```
(a) '推导'

假设 A 先手，B 后手， 以 T/F 表示“正面”/“反面”
A 获胜的情况      B 获胜的情况
  T               FT 
  FFT             FFFT
  FFFFT           FFFFFT
  ......          ......
  
计算 A 和 B 获胜概率：
A：(1/2) + (1/2)^3 + (1/2)^5 + ......
B：(1/2)^2 + (1/2)^4 + (1/2)^6 + ......

* 可用等比数列求和公式 a0(1-q^n)/(1-q) 计算；
* 可对比发现 P(B) = 1/2 * P(A) , 以及 P(B) + P(A) = 1 计算；

最终得出：
          P(A) = 2/3     P(B) = 1/3


(b) '状态机‘分析

每一次“抛硬币”均可考虑为独立事件，在不断的”抛硬币“中发生状态转移，
找到在这个过程中”等价的状态“

假设“先手“获胜的概率为 X ，则”后手“获胜首先需要”先手“第一轮抛出”反面“，
此时“后手”转换为“先手”，获胜概率为 1/2 * X ，则：

    X + 1/2 * X = 1
        3/2 * X = 1
              X = 2/3

最终得出：
          P(A) = 2/3     P(B) = 1/3

```

<br>

##### (2)  若硬币抛出“正反”时游戏结束，抛出“反面”的人获胜，

#####        则先手获胜的概率是多少

```
(a) ‘状态机’分析

由第一问已知，先手先抛出“正面”的概率是 2/3 ，后手是 1/3

当硬币序列出现第一个“正面”时，要么跟一个“反面”游戏结束，
要么始终维持该状态，保持“正面”不变

将问题分解成 “谁先抛出第一个正面” + “谁先抛出第一个反面”

”先手“先抛出第一个“正面”    2/3
    “先手”先抛出第一个“反面”    1/3  （先手赢）
    “后手”先抛出第一个“反面”    2/3  （后手赢）
“后手”先抛出第一个“正面”    1/3
    “先手”先抛出第一个“反面”    2/3  （先手赢）
    “后手”先抛出第一个“反面”    1/3  （后手赢）
      
最终得出：
          P(A) = 2/3 * 1/3 + 1/3 * 2/3 = 4/9
          P(B) = 2/3 * 2/3 + 1/3 * 1/3 = 5/9

```

<br>

##### (3) 若硬币抛出“正正”时游戏结束，抛出第二个“正面”的人获胜，

#####       则先手获胜的概率是多少

```
(a) ‘状态机’分析

由第一问已知，先手先抛出“正面”的概率是 2/3 ，后手是 1/3

当硬币序列出现第一个“正面”时，要么跟一个“正面”游戏结束，
要么跟一个”反面“，回归原始状态（等待下一个“正面”）

假设”先手“获胜概率为 X

”先手“先抛出第一个“正面”  2/3
    直接跟一个“正面”  1/2    （后手赢）
    直接跟一个“反面”  1/2    （先手赢概率 X ，后手赢概率 1-X）
“后手”先抛出第一个“正面”  1/3
    直接跟一个“正面”  1/2    （先手赢）
    直接跟一个“反面”  1/2    （先手赢概率 1-X ，后手赢概率 X）    
则：
       X = 2/3 * 1/2 * X + 1/3 * 1/2 + 1/3 * 1/2 * (1-X)
       X = 1/3 * X + 1/6 + 1/6 - 1/6 * X
       X = 1/6 * X + 1/3
 5/6 * X = 1/3
       X = 1/3 * 6/5
       X = 2/5
      
最终得出：
          P(A) = 2/5     P(B) = 3/5
      
```

<br>

<br>

<h3>B . 扔鸡蛋计算硬度问题</h3>

> 设有 K 个鸡蛋， N 级台阶，鸡蛋在某一级台阶往底层扔，当鸡蛋在第 n 层开始碎掉时，表示鸡蛋的硬度为 n ，请提供一种方案，使得无论鸡蛋的硬度是多少，测试的次数尽量少

<br>

(个人整理方法，若有不同解决方案，仅供参考）

##### (1)  若 K = 2，N = 100 

```
(a) ‘平衡’分析

假设使用“二分法”，从 50 层开始扔鸡蛋：
  若 50 层碎掉，则只剩一个鸡蛋，只能从第一层开始扔
  若 50 层没碎掉，则可以继续使用二分法，从 75 层扔
  
分析发现，在最好情况下，测试次数为 logN 级别，
        但在最坏情况下，测试次数为 N/2 次，故该方法不够“平衡”

为追求“平衡”，尽量使得方案的每种情况下，最坏尝试次数相同   

当在 m 层测试时，若鸡蛋碎掉，最坏尝试次数为 m ，
再选择在 n 层尝试，若鸡蛋碎掉，最坏尝试次数为 1+n-m
则：  m = 1+n-m   =>   n-m = m-1

推导得出，每次增加的步长依次减 1 

m + (m-1) + (m-2) + ... + 1 >= 100
                   (m+1)m/2 >= 100
                          m >= 14

最终得出：
       测试方案从 14 层开始，若鸡蛋没碎，
       之后依次选择 27，39，50，60，69，77，84，90，95，99
      
```

<br>

##### (2)  若 K 、N 未知，给出通用解

```
(a) ‘平衡’分析

反向考虑问题，当拥有 K 个鸡蛋时，尝试次数为 x ，则可以测量的层数为 f_K(x)
得出：

when K = 1 ,
      f_K(x) = x
when K >= 2 ,
      f_K(x) = x + f_K-1(x-1) + f_K-1(x-2) + ... + f_K-1(0)
when K >= x , 
      f_K(x) = x + f_K-1(x-1) + ... + f_K-1(0)
             = 2^x - 1  (binary search)

证明：
（前两个条件由推导得出，现证明第三个等式）
 f_K(x) 可以展开使得 K => K-1 
 当 K 足够大时 (K >= x)，可忽略 K，即：
        f(x) = x + f(x-1) + f(x-2) + ... + f(1)
             = x + (x-1) + 2[f(x-2) + ... + f(1)]
             = 2x + 2[f(x-2) + ... + f(1)] - 1
             = 2[x + f(x-2) + ... + f(1)] - 1
             = 2[2(x-1) + 2[f(x-3) + ... + f(1)]] - 1
             = 2^2[(x-1) + [f(x-3) + ... + f(1)]] - 1
             = 2^(x-2) [(x - (x-3)) + f(x - (x-3+2))] - 1
             = 2^(x-2)[3 + f(1)] - 1
             = 2^(x-2) * 2^2 - 1
             = 2^x - 1
             
  可发现，当鸡蛋足够多时，策略转化为“二分搜索”

```

```python
# coding

dict_tmp = {}
def func_compute(k, x):
  # f_K(x) = x , K=1 ;  
  # f_K(x) = x + f_K-1(x-1) + f_K-1(x-2) + ... + f_K-1(0) , K>=2
  # when K >= x , f_K(x) = x + f_K-1(x-1) + ... + f_K-1(0) = 2^x - 1  (binary search)
  
  if k == 1:  
      return x      
  else:    
      key = str(k)+'_'+str(x)
      if key in dict_tmp.keys():
          return dict_tmp[key]
      sum = x
      tmp = x-1
      while(tmp >= 0):
          sum += func_compute(k-1, tmp)
          tmp -= 1
      dict_tmp[key] = sum
      return sum 
    
def superEggDrop(K, N):     
    if N == 1:
        return 1
    if K == 1:
        return N

    left = 1
    right = N
    while(left < right):
        if right - left > 100:
            x_tmp = int(left + (right - left) / 20)
        else:
            x_tmp = int(left + (right - left) / 2)
        result_tmp = func_compute(K, x_tmp)
        if result_tmp > N:
            if right - left == 1:
                return left
            right = x_tmp
        elif result_tmp < N:
            if right-left == 1:
                return right
            left = x_tmp
        else:
            return x_tmp
    return x_tmp
```

<br>



<br>
<br>


